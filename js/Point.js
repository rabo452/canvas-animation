export default class Point {
    // this map object contains the certain point key and % in the value
    // after the point is connected to another point by line
    // this map will store the % of height of line to another point
    points_to_connect = new Map();

    x = 0;
    y = 0;
    
    delta_x = 0;
    delta_y = 0;
    
    min_y = 20;
    min_x = 20;
    
    max_x = 0;
    max_y = 0;

    margin = 0; // the canvas border margin

    constructor(x, y, canvas_width, canvas_height, margin, user_point = false) {
        this.x = x;
        this.y = y;
        this.delta_x = random_number(-2, 2);
        this.delta_y = random_number(-2, 2);
        this.max_x = canvas_width;
        this.max_y = canvas_height;

        this.margin = margin;
        this.user_point = user_point;
    }

    // in the next frame point should change position
    change_position() {
        // if this user point (point generated by user mouseover event) then it'll not change pos
        if (this.user_point)
            return;

        this.x += this.delta_x;
        this.y += this.delta_y;

        // if point go outside of the canvas width, height it should change the delta_x, delta_y
        if (this.x >= (this.max_x - this.margin)) {
            this.delta_x = random_number(-2, 0);
            this.delta_y = random_number(-2, 2);
        }

        if (this.x <= (this.min_x + this.margin)) {
            this.delta_x = random_number(0, 2);
            this.delta_y = random_number(-2, 2);
        }

        if (this.y >= (this.max_y - this.margin)) {
            this.delta_x = random_number(-2, 2);
            this.delta_y = random_number(-2, 0);
        }

        if (this.y <= (this.min_y + this.margin)) {
            this.delta_x = random_number(-2, 2);
            this.delta_y = random_number(0, 2);
        }
    }

    // get lines from x, y point to x, y point
    get_lines_to_closets_points(points) {
        var closest_points = this.get_closest_points(points);
        var lines = [];

        for (var point of closest_points) {
            // get percent of height of the line to another point
            var height_percent = 5;
            if (this.points_to_connect.has(point) === false) {
                this.points_to_connect.set(point, height_percent);
            }else {
                height_percent = this.points_to_connect.get(point);

                if (height_percent >= 100) {
                    this.points_to_connect.set(point, 100);
                }else {
                    // add height percent 
                    this.points_to_connect.set(point, height_percent + 5);
                }
            }

            lines.push({
                from_point: {
                    x: this.x,
                    y: this.y
                },
                to_point: {
                    x: this.x + (((point.x - this.x) / 100) * height_percent),
                    y: this.y + (((point.y - this.y) / 100) * height_percent)
                }
            });
        }

        // after that check for another points and delete their height percent if they go out from the point
        for (var point of this.points_to_connect.keys()) {
            var percent_value = this.points_to_connect.get(point);
            percent_value -= 2;
            this.points_to_connect.set(point, percent_value);

            if (percent_value <= 0) {
                this.points_to_connect.delete(point);
            }
        }

        return lines;
    }

    get_closest_points(points) {
        var closest_points = [];

        for (var point of points) {
            if (point == this) {
                continue;
            }

            // if this point very close to another point, it'll connect the points by line
            if (Math.abs(point.y - this.y) <= 200 && Math.abs(point.x - this.x) <= 200) {
                closest_points.push(point);
            }
            
        }

        return closest_points;
    }
}

// get random number from need numbers range
export function random_number(min, max) {
    var rand_number = Math.floor(Math.random() * (max - min + 1)) + min;

    // too low value don't return
    if (Math.abs(rand_number) <= 0.15)
        return random_number(min, max);
    return rand_number;
}