import Point, { random_number } from "./Point.js";

// colors
const colors = {
    'white': 0x000000,
    'grey': 'rgb(194, 77, 151)',
    'black': 'black'
}

const point_radius = 10;
const points_count = 30;
const margin = 40; // canvas margin border

class Animation {
    points = [];

    constructor() {
        this._canvas = document.querySelector('#canvas');
        this._ctx = this._canvas.getContext('2d');

        this._ctx.globalCompositeOperation = 'destination-over';
        this.init_points();
    }

    create_frame() {
        this.clear_canvas();

        var points_lines_info = [];

        for (var point of this.points) {
            point.change_position();
            this.paint_point(point.x, point.y);

            points_lines_info.push(point.get_lines_to_closets_points(this.points));
        }

        // paint lines after pointing the points, that the lines would be behind of the points
        for (var point_lines_info of points_lines_info) {
            for (var line of point_lines_info) {
                this.paint_line(line);
            }
        }
    }

    paint_line(line_info) {
        this._ctx.beginPath();
        
        this._ctx.moveTo(line_info.from_point.x, line_info.from_point.y);
        this._ctx.lineTo(line_info.to_point.x, line_info.to_point.y);

        this._ctx.lineWidth = point_radius / 5;
        this._ctx.strokeStyle = colors['black'];
        this._ctx.stroke();

        this._ctx.closePath();
    }

    init_points() {
        for (var i = 0; i < points_count; i++) {
            var rand_x = random_number(margin, this._canvas.width - margin); // within canvas height and width with margin
            var rand_y = random_number(margin, this._canvas.height - margin);

            this.points.push(new Point(rand_x, rand_y, this._canvas.width, this._canvas.height, margin));
        }
    }

    clear_canvas() {
        this._ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    paint_point(x, y) {
        this._ctx.beginPath();
        
        this._ctx.arc(x, y, point_radius, 0, Math.PI * 2);
        this._ctx.fillStyle = colors['grey'];
        this._ctx.fill();

        this._ctx.arc(x, y, point_radius, 0, Math.PI * 2);
        this._ctx.lineStyle = colors['black'];
        this._ctx.strokeWidth = point_radius;
        this._ctx.stroke();

        this._ctx.closePath();
    }

    delete_user_point_from_points(user_point) {
        for (var i = 0; i < this.points.length; i++) {
            var point = this.points[i];

            if (user_point == point) {
                this.points.splice(i, 1);
                break;
            }
        }
    }
}

// resize canvas after resizing windows, create new points after that
function resize_window() {
    animation_obj._canvas.width = document.body.clientWidth;
    animation_obj._canvas.height = document.body.clientHeight;
    animation_obj.clear_canvas();
    animation_obj = new Animation();
}

function animate() {
    requestAnimationFrame(animate);

    animation_obj.create_frame();
}


var animation_obj = new Animation();
document.body.onresize = resize_window;
resize_window();

animate();

// point generated by user event
var user_point;
animation_obj._canvas.onmousemove = function(e) {
    var mouse_x = e.x;
    var mouse_y = e.y;
    
    var temp_user_point = new Point(mouse_x, mouse_y, animation_obj._canvas.width, animation_obj._canvas.height, margin, true);

    // delete previous user point
    if (user_point) {
        animation_obj.delete_user_point_from_points(user_point);
        temp_user_point.points_to_connect = user_point.points_to_connect;
    }
    user_point = temp_user_point;

    animation_obj.points.push(user_point);
}